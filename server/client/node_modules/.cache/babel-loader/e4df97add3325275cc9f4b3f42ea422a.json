{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport SubmissionError from './SubmissionError';\n\nvar isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === SubmissionError.name;\n};\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, syncErrors);\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      values = props.values,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, Array.from(fields)); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var doSubmit = function doSubmit() {\n      var result;\n\n      try {\n        result = submit(values, dispatch, props);\n      } catch (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      }\n\n      if (isPromise(result)) {\n        startSubmit();\n        return result.then(function (submitResult) {\n          stopSubmit();\n          setSubmitSucceeded();\n\n          if (onSubmitSuccess) {\n            onSubmitSuccess(submitResult, dispatch, props);\n          }\n\n          return submitResult;\n        }, function (submitError) {\n          var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n          stopSubmit(error);\n          setSubmitFailed.apply(void 0, fields);\n\n          if (onSubmitFail) {\n            onSubmitFail(error, dispatch, submitError, props);\n          }\n\n          if (error || onSubmitFail) {\n            // if you've provided an onSubmitFail callback, don't re-throw the error\n            return error;\n          } else {\n            throw submitError;\n          }\n        });\n      } else {\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(result, dispatch, props);\n        }\n      }\n\n      return result;\n    };\n\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return doSubmit();\n      }).catch(function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return doSubmit();\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;","map":{"version":3,"sources":["/Users/bambi/react/server/client/node_modules/redux-form/es/handleSubmit.js"],"names":["_extends","isPromise","SubmissionError","isSubmissionError","error","name","mergeErrors","_ref","asyncErrors","syncErrors","merge","toJS","handleSubmit","submit","props","valid","asyncValidate","fields","dispatch","onSubmitFail","onSubmitSuccess","startSubmit","stopSubmit","setSubmitFailed","setSubmitSucceeded","touch","values","persistentSubmitErrors","apply","Array","from","doSubmit","result","submitError","errors","undefined","then","submitResult","asyncValidateResult","catch","Promise","reject"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport SubmissionError from './SubmissionError';\n\nvar isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === SubmissionError.name;\n};\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, syncErrors);\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      values = props.values,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  touch.apply(void 0, Array.from(fields)); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var doSubmit = function doSubmit() {\n      var result;\n\n      try {\n        result = submit(values, dispatch, props);\n      } catch (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      }\n\n      if (isPromise(result)) {\n        startSubmit();\n        return result.then(function (submitResult) {\n          stopSubmit();\n          setSubmitSucceeded();\n\n          if (onSubmitSuccess) {\n            onSubmitSuccess(submitResult, dispatch, props);\n          }\n\n          return submitResult;\n        }, function (submitError) {\n          var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n          stopSubmit(error);\n          setSubmitFailed.apply(void 0, fields);\n\n          if (onSubmitFail) {\n            onSubmitFail(error, dispatch, submitError, props);\n          }\n\n          if (error || onSubmitFail) {\n            // if you've provided an onSubmitFail callback, don't re-throw the error\n            return error;\n          } else {\n            throw submitError;\n          }\n        });\n      } else {\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(result, dispatch, props);\n        }\n      }\n\n      return result;\n    };\n\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return doSubmit();\n      }).catch(function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return doSubmit();\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;"]},"metadata":{},"sourceType":"module"}